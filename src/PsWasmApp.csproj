<Project Sdk="Microsoft.NET.Sdk.WebAssembly">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <PublishTrimmed>true</PublishTrimmed>
    <SuppressTrimAnalysisWarnings>true</SuppressTrimAnalysisWarnings>
    <RuntimeIdentifier>browser-wasm</RuntimeIdentifier>
    <WasmMainJSPath>wwwroot\app.js</WasmMainJSPath>
    <RunAOTCompilation>false</RunAOTCompilation>
    <BrotliCompression>true</BrotliCompression>
    <GzipCompression>false</GzipCompression>
    <WasmStripILAfterAOT>true</WasmStripILAfterAOT>
  </PropertyGroup>

  <Target Name="RemoveUnwantedFiles" AfterTargets="ComputeFilesToPublish">
    <ItemGroup>
      <ResolvedFileToPublish Remove="@(ResolvedFileToPublish)" Condition="'%(Extension)' == '.a' or '%(Extension)' == '.c' or '%(Extension)' == '.h'" />
    </ItemGroup>
  </Target>

  <ItemGroup>
    <PackageReference Include="RoslynCodeTaskFactory" Version="2.0.7" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <PackageDownload Include="System.Management.Automation" Version="[7.4.1]" />
  </ItemGroup>

  <UsingTask TaskName="CompilePwshScripts"
             TaskFactory="RoslynCodeTaskFactory.CodeTaskFactory"
             AssemblyFile="$(RoslynCodeTaskFactory)"
             Condition="'$(RoslynCodeTaskFactory)' != ''">
    <ParameterGroup>
      <HtmlPath ParameterType="System.String" Required="true" />
      <OutputPath ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="$(NuGetPackageRoot)system.management.automation\7.4.1\runtimes\win\lib\net8.0\System.Management.Automation.dll" />
      <Using Namespace="System" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Management.Automation.Language" />
      <Using Namespace="System.Text" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Class" Language="cs"><![CDATA[
        using System;
        using System.Collections.Generic;
        using System.IO;
        using System.Linq;
        using System.Management.Automation.Language;
        using Microsoft.Build.Framework;
        using System.Reflection;
        using System.Text;
        using System.Text.RegularExpressions;
        using Microsoft.Build.Utilities;

        public class CompilePwshScripts : Task
        {
            public string HtmlPath { get; set; } = string.Empty;
            public string OutputPath { get; set; } = string.Empty;

            public override bool Execute()
            {
                try
                {
                    PreloadPowerShellAssemblies();
                    var blocks = ExtractBlocks(HtmlPath);
                    var code = Generate(blocks);
                    Directory.CreateDirectory(Path.GetDirectoryName(OutputPath)!);
                    File.WriteAllText(OutputPath, code, Encoding.UTF8);
                    Log.LogMessage(MessageImportance.High, "Generated: " + OutputPath);
                    return true;
                }
                catch (Exception ex)
                {
                    Log.LogErrorFromException(ex, true);
                    return false;
                }
            }

            private List<string> ExtractBlocks(string htmlPath)
            {
                var list = new List<string>();
                if (!File.Exists(htmlPath))
                {
                    Log.LogWarning($"index.html not found at {htmlPath}");
                    return list;
                }

                var html = File.ReadAllText(htmlPath);
                var matches = Regex.Matches(html, "<script\\s+type=\"pwsh\"[^>]*>(?<code>.*?)</script>", RegexOptions.Singleline | RegexOptions.IgnoreCase);
                foreach (Match m in matches)
                {
                    var code = m.Groups["code"].Value.Trim();
                    if (!string.IsNullOrWhiteSpace(code))
                    {
                        list.Add(code);
                    }
                }
                return list;
            }

            private void PreloadPowerShellAssemblies()
            {
                var userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
                var asmPath = Path.Combine(userProfile, ".nuget", "packages", "system.management.automation", "7.4.1", "runtimes", "win", "lib", "net8.0", "System.Management.Automation.dll");
                if (File.Exists(asmPath))
                {
                    Assembly.LoadFrom(asmPath);
                }
            }

            private string Generate(List<string> blocks)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// Auto-generated from inline PowerShell (index.html) at build time");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using System.Threading.Tasks;");
                sb.AppendLine("namespace PsWasmApp;");
                sb.AppendLine("public static partial class CompiledPowerShell");
                sb.AppendLine("{");
                sb.AppendLine("    public static async Task<string> ExecuteAsync()");
                sb.AppendLine("    {");
                sb.AppendLine("        var outputs = new List<string>();");

                foreach (var block in blocks)
                {
                    sb.AppendLine("        {");
                    sb.AppendLine("            var blockOutputs = new List<string>();");
                    sb.Append(CompileBlock(block));
                    sb.AppendLine("            outputs.Add(string.Join(Environment.NewLine, blockOutputs));");
                    sb.AppendLine("        }");
                }

                sb.AppendLine("        if (outputs.Count == 0) return string.Empty;");
                sb.AppendLine("        return string.Join(Environment.NewLine, outputs);");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                return sb.ToString();
            }

            private string CompileBlock(string code)
            {
                var sb = new StringBuilder();
                Token[] tokens;
                ParseError[] errors;
                var ast = Parser.ParseInput(code, out tokens, out errors);
                if (errors != null && errors.Length > 0)
                {
                    sb.AppendLine($"            blockOutputs.Add(\"Parse error: {errors[0].Message.Replace("\"", "\\\"")}\");");
                    return sb.ToString();
                }

                var hashtables = new Dictionary<string, (Dictionary<string, string> Params, Dictionary<string, string> EnvRefs)>(StringComparer.OrdinalIgnoreCase);

                foreach (var stmt in ast.EndBlock.Statements)
                {
                    if (stmt is AssignmentStatementAst assign)
                    {
                        Ast rhs = assign.Right;
                        if (rhs is PipelineAst rhsPipe &&
                            rhsPipe.PipelineElements.Count == 1 &&
                            rhsPipe.PipelineElements[0] is CommandExpressionAst pipeCea)
                        {
                            rhs = pipeCea.Expression;
                        }
                        else if (rhs is CommandExpressionAst cea)
                        {
                            rhs = cea.Expression;
                        }

                        if (rhs is HashtableAst hta)
                        {
                            var name = assign.Left is VariableExpressionAst v
                                ? v.VariablePath.UserPath
                                : assign.Left.Extent.Text.TrimStart('$');
                            hashtables[name] = ConvertHashtable(hta);
                        }
                    }
                }

                foreach (var stmt in ast.EndBlock.Statements)
                {
                    if (stmt is PipelineAst pipe && pipe.PipelineElements.Count == 1 && pipe.PipelineElements[0] is CommandAst cmd)
                    {
                        var name = cmd.GetCommandName();
                        if (string.IsNullOrEmpty(name)) continue;

                        if (name.Equals("Write-Output", StringComparison.OrdinalIgnoreCase))
                        {
                            var arg = cmd.CommandElements.Skip(1).FirstOrDefault(e => e is not CommandParameterAst) as ExpressionAst;
                            var message = ResolveScalarValue(arg, "write-output", new Dictionary<string, string>()) ?? string.Empty;
                            sb.AppendLine($"            blockOutputs.Add(\"{message.Replace("\"", "\\\"")}\");");
                            continue;
                        }

                        if (name.Equals("Read-AzCosmosItems", StringComparison.OrdinalIgnoreCase))
                        {
                            var info = CollectCommandParameters(cmd, hashtables);
                            var p = info.Params;
                            var envRefs = info.EnvRefs;

                            p.TryGetValue("databasename", out var databaseName);
                            p.TryGetValue("containername", out var containerName);
                            p.TryGetValue("accountname", out var accountName);

                            var top = p.TryGetValue("top", out var topStr) && int.TryParse(topStr, out var topVal) ? topVal : 1;
                            var query = p.TryGetValue("query", out var queryStr) ? queryStr : $"SELECT TOP {top} * FROM c";
                            var partitionKey = p.TryGetValue("partitionkey", out var pk) ? pk : string.Empty;

                            var connectionString = string.Empty;
                            var isDynamic = false;
                            var envVar = string.Empty;

                            if (p.TryGetValue("connectionstring", out var cs))
                            {
                                connectionString = cs;
                            }
                            else if (!string.IsNullOrWhiteSpace(accountName) && p.TryGetValue("accountkey", out var accountKey))
                            {
                                if (envRefs.TryGetValue("accountkey", out var envRef))
                                {
                                    envVar = envRef;
                                    isDynamic = true;
                                }
                                else if (IsEnvIdentifier(accountKey))
                                {
                                    envVar = accountKey;
                                    isDynamic = true;
                                }
                                else
                                {
                                    if (string.IsNullOrWhiteSpace(accountKey))
                                    {
                                        sb.AppendLine("            blockOutputs.Add(\"Cosmos AccountKey not provided (check environment variable).\");");
                                        continue;
                                    }
                                    if (accountKey.StartsWith("=", StringComparison.Ordinal)) accountKey = accountKey.TrimStart('=');
                                    var endpoint = $"https://{accountName}.documents.azure.com:443/";
                                    connectionString = $"AccountEndpoint={endpoint};AccountKey={accountKey};";
                                }
                            }

                            if (string.IsNullOrWhiteSpace(databaseName) || string.IsNullOrWhiteSpace(containerName))
                            {
                                sb.AppendLine("            blockOutputs.Add(\"Cosmos parameters missing.\");");
                                continue;
                            }

                            query = query.Replace("\"", "\\\"");
                            partitionKey = partitionKey.Replace("\"", "\"\"");

                            if (isDynamic)
                            {
                                sb.AppendLine($@"            string? accountKey = Environment.GetEnvironmentVariable(""{envVar}"");
            if (string.IsNullOrWhiteSpace(accountKey))
            {{
                accountKey = BuildSecrets.CosmosKey;
            }}
            if (string.IsNullOrWhiteSpace(accountKey))
            {{
                blockOutputs.Add(""Environment variable {envVar} not set."");
            }}
            else
            {{
                if (accountKey.StartsWith(""="")) accountKey = accountKey.TrimStart('=');
                string endpoint = ""https://{accountName}.documents.azure.com:443/"";
                string connectionString = $""AccountEndpoint={{endpoint}};AccountKey={{accountKey}};"";
                blockOutputs.Add(await ReadFirstCosmosItemViaRestAsync(connectionString, ""{databaseName}"", ""{containerName}"", @""{query}"", @""{partitionKey}""));
            }}");
                            }
                            else
                            {
                                connectionString = connectionString.Replace("\"", "\"\"");
                                sb.AppendLine($@"            blockOutputs.Add(await ReadFirstCosmosItemViaRestAsync(
                @""{connectionString}"",
                ""{databaseName}"",
                ""{containerName}"",
                @""{query}"",
                @""{partitionKey}""));");
                            }
                        }
                    }
                }

                return sb.ToString();
            }

            private (Dictionary<string, string> Params, Dictionary<string, string> EnvRefs) CollectCommandParameters(CommandAst cmd, Dictionary<string, (Dictionary<string, string> Params, Dictionary<string, string> EnvRefs)> hashtables)
            {
                var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                var envRefs = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                var elements = cmd.CommandElements;
                for (int i = 1; i < elements.Count; i++)
                {
                    var el = elements[i];
                    if (el is CommandParameterAst p)
                    {
                        var name = p.ParameterName?.ToLowerInvariant();
                        if (string.IsNullOrEmpty(name)) continue;
                        var arg = p.Argument;
                        if (arg == null && i + 1 < elements.Count && elements[i + 1] is not CommandParameterAst)
                        {
                            arg = elements[i + 1] as ExpressionAst;
                            i++;
                        }
                        map[name] = arg == null ? "true" : (ResolveScalarValue(arg, name, envRefs) ?? string.Empty);
                        continue;
                    }

                    if (el is VariableExpressionAst v && v.Splatted)
                    {
                        var name = v.VariablePath.UserPath;
                        if (hashtables.TryGetValue(name, out var ht))
                        {
                            foreach (var kvp in ht.Params) map[kvp.Key] = kvp.Value;
                            foreach (var kvp in ht.EnvRefs) envRefs[kvp.Key] = kvp.Value;
                        }
                        continue;
                    }

                    if (el is HashtableAst hta && el.Extent.Text.StartsWith("@"))
                    {
                        var ht = ConvertHashtable(hta);
                        foreach (var kvp in ht.Params) map[kvp.Key] = kvp.Value;
                        foreach (var kvp in ht.EnvRefs) envRefs[kvp.Key] = kvp.Value;
                    }
                }
                return (map, envRefs);
            }

            private (Dictionary<string, string> Params, Dictionary<string, string> EnvRefs) ConvertHashtable(HashtableAst hta)
            {
                var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                var envRefs = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                foreach (var kv in hta.KeyValuePairs)
                {
                    var keyAst = kv.Item1;
                    var valAst = kv.Item2;
                    var key = keyAst is StringConstantExpressionAst s ? s.Value : keyAst.Extent.Text;
                    var lower = key.ToLowerInvariant();
                    var value = ResolveScalarValue(valAst, lower, envRefs) ?? string.Empty;
                    if (string.IsNullOrEmpty(value) && valAst.Extent.Text.StartsWith("$env:", StringComparison.OrdinalIgnoreCase))
                    {
                        var envName = valAst.Extent.Text.Substring(5);
                        envRefs[lower] = envName;
                        value = envName;
                    }
                    map[lower] = value;
                }
                return (map, envRefs);
            }

            private string? ResolveScalarValue(Ast? expr, string paramName, Dictionary<string, string> envRefs)
            {
                if (expr == null) return null;
                if (expr is CommandExpressionAst cea) expr = cea.Expression;
                if (expr is PipelineAst pa && pa.PipelineElements.Count == 1 && pa.PipelineElements[0] is CommandExpressionAst cea2) expr = cea2.Expression;

                return expr switch
                {
                    StringConstantExpressionAst s => s.Value,
                    ConstantExpressionAst c => c.Value?.ToString(),
                    ExpandableStringExpressionAst es => es.Value,
                    VariableExpressionAst v when v.VariablePath.IsDriveQualified && v.VariablePath.DriveName.Equals("env", StringComparison.OrdinalIgnoreCase)
                        => HandleEnvVariable(v, paramName, envRefs),
                    VariableExpressionAst v => v.Extent.Text.Trim('"', '\''),
                    _ => expr.Extent.Text.Trim('"', '\'')
                };
            }

            private string HandleEnvVariable(VariableExpressionAst v, string paramName, Dictionary<string, string> envRefs)
            {
                var userPath = v.VariablePath.UserPath;
                var envName = userPath.Contains(':') ? userPath.Substring(userPath.IndexOf(':') + 1) : userPath;
                envRefs[paramName] = envName;
                var val = Environment.GetEnvironmentVariable(envName);
                return string.IsNullOrEmpty(val) ? envName : val;
            }

            private static bool IsEnvIdentifier(string value) =>
                !string.IsNullOrWhiteSpace(value) && Regex.IsMatch(value, "^[A-Za-z_][A-Za-z0-9_]*$");
        }
      ]]></Code>
    </Task>
  </UsingTask>

  <Target Name="CompilePowerShell" BeforeTargets="CoreCompile">
    <CompilePwshScripts HtmlPath="$(MSBuildThisFileDirectory)wwwroot\index.html"
                        OutputPath="$(IntermediateOutputPath)CompiledPowerShell.g.cs" />
    <ItemGroup>
      <Compile Include="$(IntermediateOutputPath)CompiledPowerShell.g.cs" />
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <CosmosKey>$(ZtechCosmosPrimaryKey)</CosmosKey>
  </PropertyGroup>

  <Target Name="GenerateBuildSecrets" BeforeTargets="CoreCompile">
    <ItemGroup>
      <_BuildSecretsLines Include="#nullable disable" />
      <_BuildSecretsLines Include="namespace PsWasmApp" />
      <_BuildSecretsLines Include="{" />
      <_BuildSecretsLines Include="    internal static class BuildSecrets" />
      <_BuildSecretsLines Include="    {" />
      <_BuildSecretsLines Include="        internal const string CosmosKey = &quot;$(CosmosKey)&quot;%3B" />
      <_BuildSecretsLines Include="    }" />
      <_BuildSecretsLines Include="}" />
    </ItemGroup>
    <WriteLinesToFile
      File="$(IntermediateOutputPath)BuildSecrets.g.cs"
      Overwrite="true"
      Lines="@(_BuildSecretsLines)" />
    <ItemGroup>
      <Compile Include="$(IntermediateOutputPath)BuildSecrets.g.cs" />
    </ItemGroup>
  </Target>
</Project>
